<!DOCTYPE html><html lang="en"><head><meta name="theme-color" content="#26a69a"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&amp;display=swap"/><link href="/styles/prism.css" rel="stylesheet"/><meta charSet="utf-8"/><title>Tsoobame Blog</title><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-87f1ab999dcd728b4b5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.e11e4af83f0aa0812396.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8433c7b5d2ef072ed9ab.js" as="script"/><link rel="preload" href="/_next/static/chunks/c9a4f367e713fe912c4c3e28559df2ed6cd86505.ec1ca650117f03916453.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-d43e18299be9e92335d6.js" as="script"/><link rel="preload" href="/_next/static/chunks/94dc8e3d1635b4ba43cc7d82c033e8ce6b696f21.01af78d7bb77b107fcad.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/data-loader-de697981f35116f27ce8.js" as="script"/><style id="jss-server-side">.MuiPaper-root {
  color: #263238;
  transition: box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
  background-color: #FFFFFF;
}
.MuiPaper-rounded {
  border-radius: 4px;
}
.MuiPaper-outlined {
  border: 1px solid #eeeeee;
}
.MuiPaper-elevation0 {
  box-shadow: none;
}
.MuiPaper-elevation1 {
  box-shadow: 0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);
}
.MuiPaper-elevation2 {
  box-shadow: 0px 3px 1px -2px rgba(0,0,0,0.2),0px 2px 2px 0px rgba(0,0,0,0.14),0px 1px 5px 0px rgba(0,0,0,0.12);
}
.MuiPaper-elevation3 {
  box-shadow: 0px 3px 3px -2px rgba(0,0,0,0.2),0px 3px 4px 0px rgba(0,0,0,0.14),0px 1px 8px 0px rgba(0,0,0,0.12);
}
.MuiPaper-elevation4 {
  box-shadow: 0px 2px 4px -1px rgba(0,0,0,0.2),0px 4px 5px 0px rgba(0,0,0,0.14),0px 1px 10px 0px rgba(0,0,0,0.12);
}
.MuiPaper-elevation5 {
  box-shadow: 0px 3px 5px -1px rgba(0,0,0,0.2),0px 5px 8px 0px rgba(0,0,0,0.14),0px 1px 14px 0px rgba(0,0,0,0.12);
}
.MuiPaper-elevation6 {
  box-shadow: 0px 3px 5px -1px rgba(0,0,0,0.2),0px 6px 10px 0px rgba(0,0,0,0.14),0px 1px 18px 0px rgba(0,0,0,0.12);
}
.MuiPaper-elevation7 {
  box-shadow: 0px 4px 5px -2px rgba(0,0,0,0.2),0px 7px 10px 1px rgba(0,0,0,0.14),0px 2px 16px 1px rgba(0,0,0,0.12);
}
.MuiPaper-elevation8 {
  box-shadow: 0px 5px 5px -3px rgba(0,0,0,0.2),0px 8px 10px 1px rgba(0,0,0,0.14),0px 3px 14px 2px rgba(0,0,0,0.12);
}
.MuiPaper-elevation9 {
  box-shadow: 0px 5px 6px -3px rgba(0,0,0,0.2),0px 9px 12px 1px rgba(0,0,0,0.14),0px 3px 16px 2px rgba(0,0,0,0.12);
}
.MuiPaper-elevation10 {
  box-shadow: 0px 6px 6px -3px rgba(0,0,0,0.2),0px 10px 14px 1px rgba(0,0,0,0.14),0px 4px 18px 3px rgba(0,0,0,0.12);
}
.MuiPaper-elevation11 {
  box-shadow: 0px 6px 7px -4px rgba(0,0,0,0.2),0px 11px 15px 1px rgba(0,0,0,0.14),0px 4px 20px 3px rgba(0,0,0,0.12);
}
.MuiPaper-elevation12 {
  box-shadow: 0px 7px 8px -4px rgba(0,0,0,0.2),0px 12px 17px 2px rgba(0,0,0,0.14),0px 5px 22px 4px rgba(0,0,0,0.12);
}
.MuiPaper-elevation13 {
  box-shadow: 0px 7px 8px -4px rgba(0,0,0,0.2),0px 13px 19px 2px rgba(0,0,0,0.14),0px 5px 24px 4px rgba(0,0,0,0.12);
}
.MuiPaper-elevation14 {
  box-shadow: 0px 7px 9px -4px rgba(0,0,0,0.2),0px 14px 21px 2px rgba(0,0,0,0.14),0px 5px 26px 4px rgba(0,0,0,0.12);
}
.MuiPaper-elevation15 {
  box-shadow: 0px 8px 9px -5px rgba(0,0,0,0.2),0px 15px 22px 2px rgba(0,0,0,0.14),0px 6px 28px 5px rgba(0,0,0,0.12);
}
.MuiPaper-elevation16 {
  box-shadow: 0px 8px 10px -5px rgba(0,0,0,0.2),0px 16px 24px 2px rgba(0,0,0,0.14),0px 6px 30px 5px rgba(0,0,0,0.12);
}
.MuiPaper-elevation17 {
  box-shadow: 0px 8px 11px -5px rgba(0,0,0,0.2),0px 17px 26px 2px rgba(0,0,0,0.14),0px 6px 32px 5px rgba(0,0,0,0.12);
}
.MuiPaper-elevation18 {
  box-shadow: 0px 9px 11px -5px rgba(0,0,0,0.2),0px 18px 28px 2px rgba(0,0,0,0.14),0px 7px 34px 6px rgba(0,0,0,0.12);
}
.MuiPaper-elevation19 {
  box-shadow: 0px 9px 12px -6px rgba(0,0,0,0.2),0px 19px 29px 2px rgba(0,0,0,0.14),0px 7px 36px 6px rgba(0,0,0,0.12);
}
.MuiPaper-elevation20 {
  box-shadow: 0px 10px 13px -6px rgba(0,0,0,0.2),0px 20px 31px 3px rgba(0,0,0,0.14),0px 8px 38px 7px rgba(0,0,0,0.12);
}
.MuiPaper-elevation21 {
  box-shadow: 0px 10px 13px -6px rgba(0,0,0,0.2),0px 21px 33px 3px rgba(0,0,0,0.14),0px 8px 40px 7px rgba(0,0,0,0.12);
}
.MuiPaper-elevation22 {
  box-shadow: 0px 10px 14px -6px rgba(0,0,0,0.2),0px 22px 35px 3px rgba(0,0,0,0.14),0px 8px 42px 7px rgba(0,0,0,0.12);
}
.MuiPaper-elevation23 {
  box-shadow: 0px 11px 14px -7px rgba(0,0,0,0.2),0px 23px 36px 3px rgba(0,0,0,0.14),0px 9px 44px 8px rgba(0,0,0,0.12);
}
.MuiPaper-elevation24 {
  box-shadow: 0px 11px 15px -7px rgba(0,0,0,0.2),0px 24px 38px 3px rgba(0,0,0,0.14),0px 9px 46px 8px rgba(0,0,0,0.12);
}
.MuiAppBar-root {
  width: 100%;
  display: flex;
  z-index: 1100;
  box-sizing: border-box;
  flex-shrink: 0;
  flex-direction: column;
}
.MuiAppBar-positionFixed {
  top: 0;
  left: auto;
  right: 0;
  position: fixed;
}
@media print {
  .MuiAppBar-positionFixed {
    position: absolute;
  }
}
  .MuiAppBar-positionAbsolute {
    top: 0;
    left: auto;
    right: 0;
    position: absolute;
  }
  .MuiAppBar-positionSticky {
    top: 0;
    left: auto;
    right: 0;
    position: sticky;
  }
  .MuiAppBar-positionStatic {
    position: static;
  }
  .MuiAppBar-positionRelative {
    position: relative;
  }
  .MuiAppBar-colorDefault {
    color: rgba(0, 0, 0, 0.87);
    background-color: #f5f5f5;
  }
  .MuiAppBar-colorPrimary {
    color: #FFFFFF;
    background-color: #26a69a;
  }
  .MuiAppBar-colorSecondary {
    color: #FFFFFF;
    background-color: #42a5f5;
  }
  .MuiAppBar-colorInherit {
    color: inherit;
  }
  .MuiAppBar-colorTransparent {
    color: inherit;
    background-color: transparent;
  }

  .jss6 {
    margin-top: 32px;
    margin-bottom: 32px;
  }
  .jss7 {
    display: flex;
    margin-top: 32px;
    margin-bottom: 32px;
    justify-content: center;
  }
  .jss8 {
    margin-left: 32px;
    margin-right: 32px;
  }
  .jss9 {
    margin-left: 32px;
    margin-right: 32px;
  }
  .MuiTypography-root {
    margin: 0;
  }
  .MuiTypography-body2 {
    font-size: 0.875rem;
    font-family: "Roboto", "Helvetica", "Arial", sans-serif;
    font-weight: 400;
    line-height: 1.43;
    letter-spacing: 0.01071em;
  }
  .MuiTypography-body1 {
    font-size: 1rem;
    font-family: "Roboto", "Helvetica", "Arial", sans-serif;
    font-weight: 400;
    line-height: 1.5;
    letter-spacing: 0.00938em;
  }
  .MuiTypography-caption {
    font-size: 0.75rem;
    font-family: "Roboto", "Helvetica", "Arial", sans-serif;
    font-weight: 400;
    line-height: 1.66;
    letter-spacing: 0.03333em;
  }
  .MuiTypography-button {
    font-size: 0.875rem;
    font-family: "Roboto", "Helvetica", "Arial", sans-serif;
    font-weight: 500;
    line-height: 1.75;
    letter-spacing: 0.02857em;
    text-transform: uppercase;
  }
  .MuiTypography-h1 {
    font-size: 6rem;
    font-family: "Roboto", "Helvetica", "Arial", sans-serif;
    font-weight: 300;
    line-height: 1.167;
    letter-spacing: -0.01562em;
  }
  .MuiTypography-h2 {
    font-size: 3.75rem;
    font-family: "Roboto", "Helvetica", "Arial", sans-serif;
    font-weight: 300;
    line-height: 1.2;
    letter-spacing: -0.00833em;
  }
  .MuiTypography-h3 {
    font-size: 3rem;
    font-family: "Roboto", "Helvetica", "Arial", sans-serif;
    font-weight: 400;
    line-height: 1.167;
    letter-spacing: 0em;
  }
  .MuiTypography-h4 {
    font-size: 2.125rem;
    font-family: "Roboto", "Helvetica", "Arial", sans-serif;
    font-weight: 400;
    line-height: 1.235;
    letter-spacing: 0.00735em;
  }
  .MuiTypography-h5 {
    font-size: 1.5rem;
    font-family: "Roboto", "Helvetica", "Arial", sans-serif;
    font-weight: 400;
    line-height: 1.334;
    letter-spacing: 0em;
  }
  .MuiTypography-h6 {
    font-size: 1.25rem;
    font-family: "Roboto", "Helvetica", "Arial", sans-serif;
    font-weight: 500;
    line-height: 1.6;
    letter-spacing: 0.0075em;
  }
  .MuiTypography-subtitle1 {
    font-size: 1rem;
    font-family: "Roboto", "Helvetica", "Arial", sans-serif;
    font-weight: 400;
    line-height: 1.75;
    letter-spacing: 0.00938em;
  }
  .MuiTypography-subtitle2 {
    font-size: 0.875rem;
    font-family: "Roboto", "Helvetica", "Arial", sans-serif;
    font-weight: 500;
    line-height: 1.57;
    letter-spacing: 0.00714em;
  }
  .MuiTypography-overline {
    font-size: 0.75rem;
    font-family: "Roboto", "Helvetica", "Arial", sans-serif;
    font-weight: 400;
    line-height: 2.66;
    letter-spacing: 0.08333em;
    text-transform: uppercase;
  }
  .MuiTypography-srOnly {
    width: 1px;
    height: 1px;
    overflow: hidden;
    position: absolute;
  }
  .MuiTypography-alignLeft {
    text-align: left;
  }
  .MuiTypography-alignCenter {
    text-align: center;
  }
  .MuiTypography-alignRight {
    text-align: right;
  }
  .MuiTypography-alignJustify {
    text-align: justify;
  }
  .MuiTypography-noWrap {
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
  }
  .MuiTypography-gutterBottom {
    margin-bottom: 0.35em;
  }
  .MuiTypography-paragraph {
    margin-bottom: 16px;
  }
  .MuiTypography-colorInherit {
    color: inherit;
  }
  .MuiTypography-colorPrimary {
    color: #26a69a;
  }
  .MuiTypography-colorSecondary {
    color: #42a5f5;
  }
  .MuiTypography-colorTextPrimary {
    color: #263238;
  }
  .MuiTypography-colorTextSecondary {
    color: #546e7a;
  }
  .MuiTypography-colorError {
    color: #e53935;
  }
  .MuiTypography-displayInline {
    display: inline;
  }
  .MuiTypography-displayBlock {
    display: block;
  }
  .MuiContainer-root {
    width: 100%;
    display: block;
    box-sizing: border-box;
    margin-left: auto;
    margin-right: auto;
    padding-left: 16px;
    padding-right: 16px;
  }
@media (min-width:600px) {
  .MuiContainer-root {
    padding-left: 24px;
    padding-right: 24px;
  }
}
  .MuiContainer-disableGutters {
    padding-left: 0;
    padding-right: 0;
  }
@media (min-width:600px) {
  .MuiContainer-fixed {
    max-width: 600px;
  }
}
@media (min-width:960px) {
  .MuiContainer-fixed {
    max-width: 960px;
  }
}
@media (min-width:1280px) {
  .MuiContainer-fixed {
    max-width: 1280px;
  }
}
@media (min-width:1920px) {
  .MuiContainer-fixed {
    max-width: 1920px;
  }
}
@media (min-width:0px) {
  .MuiContainer-maxWidthXs {
    max-width: 444px;
  }
}
@media (min-width:600px) {
  .MuiContainer-maxWidthSm {
    max-width: 600px;
  }
}
@media (min-width:960px) {
  .MuiContainer-maxWidthMd {
    max-width: 960px;
  }
}
@media (min-width:1280px) {
  .MuiContainer-maxWidthLg {
    max-width: 1280px;
  }
}
@media (min-width:1920px) {
  .MuiContainer-maxWidthXl {
    max-width: 1920px;
  }
}
html {
  box-sizing: border-box;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
*, *::before, *::after {
  box-sizing: inherit;
}
strong, b {
  font-weight: 700;
}
body {
  color: #263238;
  margin: 0;
  font-size: 0.875rem;
  font-family: "Roboto", "Helvetica", "Arial", sans-serif;
  font-weight: 400;
  line-height: 1.43;
  letter-spacing: 0.01071em;
  background-color: #F4F6F8;
}
@media print {
  body {
    background-color: #fff;
  }
}
body::backdrop {
  background-color: #F4F6F8;
}
  .MuiLink-underlineNone {
    text-decoration: none;
  }
  .MuiLink-underlineHover {
    text-decoration: none;
  }
  .MuiLink-underlineHover:hover {
    text-decoration: underline;
  }
  .MuiLink-underlineAlways {
    text-decoration: underline;
  }
  .MuiLink-button {
    border: 0;
    cursor: pointer;
    margin: 0;
    outline: 0;
    padding: 0;
    position: relative;
    user-select: none;
    border-radius: 0;
    vertical-align: middle;
    -moz-appearance: none;
    background-color: transparent;
    -webkit-appearance: none;
    -webkit-tap-highlight-color: transparent;
  }
  .MuiLink-button::-moz-focus-inner {
    border-style: none;
  }
  .MuiLink-button.Mui-focusVisible {
    outline: auto;
  }
  .MuiToolbar-root {
    display: flex;
    position: relative;
    align-items: center;
  }
  .MuiToolbar-gutters {
    padding-left: 16px;
    padding-right: 16px;
  }
@media (min-width:600px) {
  .MuiToolbar-gutters {
    padding-left: 24px;
    padding-right: 24px;
  }
}
  .MuiToolbar-regular {
    min-height: 56px;
  }
@media (min-width:0px) and (orientation: landscape) {
  .MuiToolbar-regular {
    min-height: 48px;
  }
}
@media (min-width:600px) {
  .MuiToolbar-regular {
    min-height: 64px;
  }
}
  .MuiToolbar-dense {
    min-height: 48px;
  }
  .jss1 {
    top: 0;
    width: 100%;
    position: fixed;
    background: linear-gradient(90deg, #0077c2, #00766c);
    border-bottom: 1px solid #eeeeee;
  }
  .jss2 {
    flex: 1;
  }
  .jss3 {
    overflow-x: auto;
    justify-content: space-between;
  }
  .jss4 {
    padding: 8px;
    flex-shrink: 0;
  }
  .jss10 {
    color: #FFFFFF;
    width: 100%;
    bottom: 0;
    padding: 16px 0px;
    position: fixed;
    background: linear-gradient(90deg, #00766c, #0077c2);
  }</style></head><body><div id="__next"><header class="MuiPaper-root MuiAppBar-root MuiAppBar-positionStatic MuiAppBar-colorPrimary jss5 MuiPaper-elevation4"><div class="MuiToolbar-root MuiToolbar-regular jss1 MuiToolbar-gutters"><h2 class="MuiTypography-root jss2 MuiTypography-h5 MuiTypography-colorInherit MuiTypography-noWrap MuiTypography-alignCenter"><a class="MuiTypography-root MuiLink-root MuiLink-underlineHover MuiTypography-colorInherit" href="/">Tsoobame</a></h2></div></header><div class="MuiContainer-root MuiContainer-maxWidthMd"><div class="MuiBox-root jss6"><a class="MuiTypography-root MuiLink-root MuiLink-underlineHover MuiTypography-colorPrimary" href="/">&lt; <!-- --> BACK TO BLOG</a></div><h1 class="MuiTypography-root MuiTypography-h4 MuiTypography-gutterBottom">Understanding data loader</h1><h1>Understanding the Dataloader</h1><p>Dataloader is one of the packages I find more useful and smart from the ones I have in my toolbox.</p><p>I am going to set up a obvious naive example and follow the process to build a simple dataloader to understand its beauty and how useful it is.</p><h2>About the project</h2><p>We are going to create a view and api over a social network. Our users relations are:</p><pre><code>User 1 friend of [ 2, 3 ]
User 2 friend of [ 1, 3 ]
User 3 friend of [ 1, 2, 4 ]
User 4 friend of [ 3, 5 ]
User 5 friend of [ 4 ]
</code></pre><p>The view can show the relation between users and their friends. We can show N levels of their friendship. We are not goint to look much at it in this post.</p><p>Users data can be found here.</p><p>The only dependency will be express.</p><h2>Initial Setup</h2><h3>datasource.js</h3><p>The datasource allows us to retrieve one or multiple users by id. Contract is not random, it is already based on the real dataloader so there will be minimal changes over the course of the post. Data is defined in a file within the project. Code is pretty simple:</p><pre><code class="language-javascript">const users = require(&quot;./users.json&quot;);

const getUsersFromFile = (ids) =&gt;
  ids.map((id) =&gt; users.find((u) =&gt; u.id === id));
const sleep = (ms) =&gt; new Promise((resolve) =&gt; setTimeout(resolve, ms));

async function loadMany(ids) {
  console.log(`GET /users?ids=${ids}`);

  await sleep(100);
  return getUsersFromFile(ids);
}

async function load(id) {
  const results = await loadMany([id]);
  return results[0];
}

module.exports = {
  load,
  loadMany,
};
</code></pre><p>The only interesting method is loadMany. We will print the requests to the simulated service so we can check the console. There will be a delay to resolve the promise, so we can simulate better and understand why dataloader is so good.</p><p>A very important requirement is that data needs to be returned to the caller in the right order and all elements need to be returned (same length of ids and results arrays). This will be clear when we put in place the dataloader.</p><h3>resolver.js</h3><p>Resolver will use the datasource received by parameter to load friendship data about users. It can receive the levels of friends we want to get, so it will use a recursive approach to load friends of friends until all levels are fetched.</p><pre><code class="language-javascript">async function getFriends(datasource, user, levels) {
  if (levels == 0) {
    return { id: user.id, name: user.name };
  }

  const friends = await datasource.loadMany(user.friends);

  return {
    ...user,
    friends: await Promise.all(
      friends.map((f) =&gt; getFriends(datasource, f, levels - 1))
    ),
  };
}

async function getUserWithFriends(datasource, id, levels = 1) {
  const user = await datasource.load(id);
  return getFriends(datasource, user, levels);
}

module.exports = { getUserWithFriends };
</code></pre><p>It uses a brute force approach on purpose. The code is simple but far away from being optimal. In one method it looks obvious, but sometimes, when we are building graphql or similar apis, or complex workflows we might be doing exactly this kind of brute force requests.</p><h3>view.js</h3><p>Nothing advanced. Just render users friends in a nested way.</p><pre><code class="language-javascript">function render(user) {
  return `&lt;div style=&quot;padding-left: 12px;background-color:#def&quot;&gt; ${user.name} ${
    user.friends ? user.friends.map((u) =&gt; render(u)).join(&quot;&quot;) : &quot;&quot;
  } &lt;/div&gt;`;
}

module.exports = {
  render,
};
</code></pre><h3>server.js</h3><pre><code class="language-javascript">const express = require(&quot;express&quot;);
const PORT = 3000;
const app = express();

const datasource = require(&quot;./datasource&quot;);
const resolver = require(&quot;./resolver&quot;);
const view = require(&quot;./view&quot;);

app.get(`/user-with-friends/:id`, async (req, res) =&gt; {
  const id = req.params.id;
  const levels = req.query.levels || 1;

  const user = await resolver.getUserWithFriends(datasource, id, levels);

  res.send(view.render(user));
});

app.listen(PORT, () =&gt; console.log(`Fakebook listening to ${PORT}`));
</code></pre><h2>Run</h2><pre><code>node index.js
</code></pre><h2>Test 1</h2><p>We will render friends of user 1. Only 1 level:</p><pre><code>http://localhost:3000/user-with-friends/1
</code></pre><p>If we check in our console we will find:</p><pre><code>GET /users?ids=1
GET /users?ids=2,3
</code></pre><p>All good. We requested user 1 and their friends 2 and 3.</p><h2>Test 2</h2><p>Let&#x27;s try by loading 3 levels:</p><pre><code>http://localhost:3000/user-with-friends/1?levels=3
</code></pre><p>Things are getting interesting here:</p><pre><code>GET /users?ids=1
GET /users?ids=2,3
GET /users?ids=1,3
GET /users?ids=1,2,4
GET /users?ids=2,3
GET /users?ids=1,2,4
GET /users?ids=2,3
GET /users?ids=1,3
GET /users?ids=3,5
</code></pre><p>We are loading data for users 1,2,3,4,5 but we are doing 9 requests. We are requesting the same users again and again. We could easily improve the situation adding some sort of cache per request.</p><p>Cache per request
We are going to add a cache to the system. It will be empty at the start of each request, so we do not need to worry about expirations. The benefits will be:</p><p>Do not request the same resource twice to the remote source during the same request.
As side effect, if we try to get the same resource twice during the same request, we will get the same data. So mutations of the resources in between a request will not provide incoherent results.</p><h3>cache.js</h3><p>Simple cache implementation:</p><pre><code class="language-javascript">function make(loadManyFn) {
  const cache = {};

  async function loadMany(ids) {
    const notCachedIds = ids.filter((id) =&gt; !cache[id]);

    if (notCachedIds.length &gt; 0) {
      const results = await loadManyFn(notCachedIds);
      notCachedIds.forEach((id, idx) =&gt; (cache[id] = results[idx]));
    }

    return ids.map((id) =&gt; cache[id]);
  }

  return {
    load: async (id) =&gt; {
      const results = await loadMany([id]);
      return results[0];
    },
    loadMany,
  };
}

module.exports = { make };
</code></pre><p>Cache needs a function to retrieve multiple data by id (or in general by a key). It will check the data that is cached and request only the ids that are not found.</p><p>Implements the same contract as datasource.</p><h3>server.js</h3><p>Let&#x27;s add this line to the server:</p><pre><code class="language-javascript">const cache = require(&#x27;./cache&#x27;)
And replace this line:

const user = await resolver.getUserWithFriends(datasource, id, levels)
with:

const user = await resolver.getUserWithFriends(cache.make(datasource.loadMany), id, levels)
</code></pre><h2>Run</h2><p>Let&#x27;s run again the server and test the previous request:</p><pre><code>http://localhost:3000/user-with-friends/1?levels=3
</code></pre><pre><code>GET /users?ids=1
GET /users?ids=2,3
GET /users?ids=4
GET /users?ids=4
GET /users?ids=5
</code></pre><p>We could reduce the number of requests from 9 to 5, which is pretty good. But, what a momentwhat happened here? Why are we requesting id=4 twice?</p><p>If we unnest the request flow based on how nodejs works (and how we implemented our resolver) this is what happened:</p><pre><code>1 - Load user 1 =&gt; GET /users?ids=1
2 - Load friends of 1: [2,3]=&gt; GET /users?ids=2,3
3.1. Load friends of 2: [1,3] =&gt; all cached
4.1. Load friends of 1 : [2,3] =&gt; all cached
4.2. Load friends of 3 : [1,2,4] =&gt; GET /users?ids=4
3.2. Load friends of 3: [1,2,4] =&gt; GET /users?ids=4
4.3. Load friends of 1: [2,3] =&gt; all cached
4.4. Load friends of 2: [1,3] =&gt; all cached
4.5. Load friends of 4: [3,5] =&gt; GET /users?ids=5
On 3.1 we had all friends of user 2 cached. So the code was straight to 4.2, than ran in parallel with 3.2. Both were waiting for the same user (4) and therefore made the same requests twice.
</code></pre><p>So with our simple cache, we did not reduce the requests to the minimun we wanted.</p><p>For example, if we did:</p><pre><code class="language-javascript">const users = await Promise.all(load(1), load(1));
</code></pre><p>There would be 2 requests before the cache has data for id=1.</p><p>Let&#x27;s fix this and produce the ideal:</p><pre><code>GET /users?ids=1
GET /users?ids=2,3
GET /users?ids=4
GET /users?ids=5
</code></pre><h2>Dataloader</h2><p>Using nodejs <code>process.nextTick(...)</code> we can postpone the execution of a given function to the end of the current event loop cycle. It is useful to run a given function after all variables are initialized for example.</p><p>From nodejs documentation:</p><pre><code>By using process.nextTick() we guarantee that apiCall() always runs its callback after the rest of the user&#x27;s code and before the event loop is allowed to proceed.
</code></pre><p>Using it we can accumulate all the keys that are being requested during the same cycle (3.2 and 4.2 in the example above) and request them at the end. In the next cycle we would accumulate again the ones that were depending in the previous ones and so on.</p><p>This simple version of dataloader incorporates also code to accomplish the cache:</p><pre><code class="language-javascript">function make(loadManyFn) {
  const cache = {};
  let pending = [];
  let scheduled = false;
  function scheduleSearch() {
    if (pending.length &gt; 0 &amp;&amp; !scheduled) {
      scheduled = true;
      Promise.resolve().then(() =&gt;
        process.nextTick(async () =&gt; {
          await runSearch();
          scheduled = false;
        })
      );
    }
  }

  async function runSearch() {
    const pendingCopy = pending.splice(0, pending.length);
    pending = [];

    if (pendingCopy.length &gt; 0) {
      const results = await loadManyFn(pendingCopy.map((p) =&gt; p.id));
      pendingCopy.forEach(({ resolve }, idx) =&gt; resolve(results[idx]));
    }
  }

  async function loadMany(ids) {
    const notCachedIds = ids.filter((id) =&gt; !cache[id]);

    if (notCachedIds.length &gt; 0) {
      notCachedIds.map((id) =&gt; {
        cache[id] = new Promise((resolve) =&gt; {
          pending.push({ id, resolve });
        });
      });

      scheduleSearch();
    }

    return Promise.all(ids.map((id) =&gt; cache[id]));
  }

  return {
    load: async (id) =&gt; {
      const results = await loadMany([id]);
      return results[0];
    },
    loadMany,
  };
}

module.exports = { make };
</code></pre><p>Ignoring the part of the cache, the important bits are:</p><h3>Accumulating requests</h3><pre><code class="language-javascript">notCachedIds.map((id) =&gt; {
  cache[id] = new Promise((resolve) =&gt; {
    pending.push({ id, resolve });
  });
});
</code></pre><p>We will add to the list of pending ids the ones that are not cached. We will keep the id and the resolve method, so we can resolve them afterwards with the right value. We cache the promise itself in the hashmap. This would allow us to cache also rejected promises for example. So we do not request over and over the same rejection. It is not used in this implementation, though.</p><h3>Scheduling the request</h3><pre><code class="language-javascript">function scheduleSearch() {
  if (pending.length &gt; 0 &amp;&amp; !scheduled) {
    scheduled = true;
    Promise.resolve().then(() =&gt;
      process.nextTick(async () =&gt; {
        await runSearch();
        scheduled = false;
      })
    );
  }
}
</code></pre><p>That is where the magic happens. This function is short but is the most important one: We schedule/delay the request to the end of all the promises declarations.</p><h3>Executing the search</h3><pre><code class="language-javascript">async function runSearch() {
  const pendingCopy = pending.splice(0, pending.length);
  pending = [];

  if (pendingCopy.length &gt; 0) {
    const results = await loadManyFn(pendingCopy.map((p) =&gt; p.id));
    pendingCopy.forEach(({ resolve }, idx) =&gt; resolve(results[idx]));
  }
}
</code></pre><p>Clone the ids (so they can be accumulated again after the search completes) and call the loadManyFn so we can resolve the promises we had pending. Remember the requirements of loadMany to return the data in the right order and all the elements ? This is where it is needed. We can reference the results by index and resolve the right pending promises.</p><p>Let&#x27;s run it!</p><h2>Execution</h2><p>Again the same request:</p><pre><code>http://localhost:3000/user-with-friends/1?levels=3
</code></pre><p>That produces the following output:</p><pre><code>GET /users?ids=1
GET /users?ids=2,3
GET /users?ids=4
GET /users?ids=5
</code></pre><p>Exactly what we wanted.</p><h2>Conclusion</h2><ul><li><p>Dataloader is a great package that should be in all developers toolbox. Specially the ones implementing Graphql or similar Apis.</p></li><li><p>The resolvers in this example could be optimized but sometimes our requests are on different files at different levels that depend on some conditions. With Dataloader we can keep our file structure and code readability without damaging our performance, both on response time to our client and on number of requests spawn within our mesh.</p></li></ul><p>Are you using Dataloader? Do you know any tool that accomplishes something similar? Do you now any other packages that in your opinion should be in all nodejs devs toolbox?</p><hr/><div class="MuiBox-root jss7"><div class="MuiBox-root jss8"></div><div class="MuiBox-root jss9"></div></div></div><footer class="jss10"><div class="MuiContainer-root MuiContainer-maxWidthLg"><p class="MuiTypography-root MuiTypography-body2 MuiTypography-colorInherit MuiTypography-alignCenter">Copyright © <!-- -->tsoobame.com <!-- -->2020<!-- -->.</p></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/data-loader","query":{},"buildId":"rghvBgbaJAF9kv8dh8Aky","nextExport":true,"autoExport":true,"isFallback":false,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Tsoobame Blog"}],["meta",{"name":"viewport","content":"minimum-scale=1, initial-scale=1, width=device-width"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-a98cee78eb8282e29fb6.js"></script><script src="/_next/static/chunks/main-87f1ab999dcd728b4b5b.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.e11e4af83f0aa0812396.js" async=""></script><script src="/_next/static/chunks/commons.8433c7b5d2ef072ed9ab.js" async=""></script><script src="/_next/static/chunks/c9a4f367e713fe912c4c3e28559df2ed6cd86505.ec1ca650117f03916453.js" async=""></script><script src="/_next/static/chunks/pages/_app-d43e18299be9e92335d6.js" async=""></script><script src="/_next/static/chunks/94dc8e3d1635b4ba43cc7d82c033e8ce6b696f21.01af78d7bb77b107fcad.js" async=""></script><script src="/_next/static/chunks/pages/blog/data-loader-de697981f35116f27ce8.js" async=""></script><script src="/_next/static/rghvBgbaJAF9kv8dh8Aky/_buildManifest.js" async=""></script><script src="/_next/static/rghvBgbaJAF9kv8dh8Aky/_ssgManifest.js" async=""></script></body></html>